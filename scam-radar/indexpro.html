<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bitcoin Tracer PRO - Investigation Profonde</title>
    <script src="https://cdn.jsdelivr.net/npm/vis-network/standalone/umd/vis-network.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #0c0c0c 0%, #1a1a2e 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #00b4db, #0083b0);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .search-box {
            display: flex;
            gap: 10px;
        }

        .search-box input {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            width: 500px;
            font-size: 16px;
            background: rgba(255, 255, 255, 0.9);
        }

        .search-box button, .control-btn {
            padding: 12px 20px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(45deg, #00b4db, #0083b0);
            color: white;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .control-btn {
            background: linear-gradient(45deg, #ffa502, #ff7b00);
        }

        .search-box button:hover, .control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }

        .dashboard {
            display: grid;
            grid-template-columns: 1fr 500px;
            gap: 20px;
            margin-top: 20px;
        }

        .network-container {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            height: 800px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            position: relative;
        }

        #network {
            width: 100%;
            height: 100%;
            border-radius: 10px;
            background: rgba(0, 0, 0, 0.3);
        }

        .network-controls {
            position: absolute;
            top: 30px;
            right: 30px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
            border-radius: 10px;
            z-index: 1000;
        }

        .info-panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            overflow-y: auto;
            max-height: 800px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tab-container {
            margin-top: 20px;
        }

        .tabs {
            display: flex;
            gap: 5px;
            margin-bottom: 15px;
        }

        .tab {
            padding: 10px 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px 8px 0 0;
            cursor: pointer;
            transition: all 0.3s;
        }

        .tab.active {
            background: #00b4db;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .transaction-item, .address-item {
            background: rgba(255, 255, 255, 0.08);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 4px solid #00b4db;
            cursor: pointer;
            transition: all 0.3s;
        }

        .address-item {
            border-left-color: #ffa502;
        }

        .transaction-item:hover, .address-item:hover {
            background: rgba(255, 255, 255, 0.12);
            transform: translateX(5px);
        }

        .risk-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 12px;
            font-size: 12px;
            margin-left: 10px;
        }

        .risk-high { background: #ff4757; }
        .risk-medium { background: #ffa502; }
        .risk-low { background: #2ed573; }

        .loading {
            text-align: center;
            padding: 40px;
            font-size: 18px;
        }

        .node-details {
            background: rgba(255, 255, 255, 0.08);
            padding: 20px;
            border-radius: 10px;
            margin-top: 20px;
            font-family: monospace;
            font-size: 12px;
        }

        .detail-section {
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .action-buttons {
            display: flex;
            gap: 10px;
            margin-top: 15px;
            flex-wrap: wrap;
        }

        .action-btn {
            padding: 8px 15px;
            border: none;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s;
        }

        .action-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }

        .investigation-path {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            border-radius: 10px;
            margin-top: 15px;
            font-size: 14px;
        }

        .path-step {
            display: flex;
            align-items: center;
            margin: 10px 0;
            padding: 10px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
        }

        .path-arrow {
            margin: 0 15px;
            color: #00b4db;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>Bitcoin Tracer PRO - Investigation Profonde</h1>
            <p>Outil avanc√© de tra√ßage blockchain avec analyse multi-niveaux</p>
            
            <div class="controls">
                <div class="search-box">
                    <input type="text" id="btcAddress" placeholder="Entrez une adresse Bitcoin pour investigation" value="">
                    <button onclick="startDeepAnalysis()">Investigation Profonde</button>
                </div>
                <button class="control-btn" onclick="expandNetwork()">√âtendre l'Analyse</button>
                <button class="control-btn" onclick="findKYCPaths()">Chercher KYC</button>
            </div>
        </div>

        <div class="dashboard">
            <div class="network-container">
                <div class="network-controls">
                    <button class="action-btn" onclick="exportData()">üíæ Export</button>
                    <button class="action-btn" onclick="clearNetwork()">üóëÔ∏è Reset</button>
                </div>
                <div id="network"></div>
            </div>

            <div class="info-panel">
                <div class="tabs">
                    <div class="tab active" onclick="switchTab('transactions')">Transactions</div>
                    <div class="tab" onclick="switchTab('addresses')">Adresses</div>
                    <div class="tab" onclick="switchTab('details')">D√©tails</div>
                    <div class="tab" onclick="switchTab('investigation')">Investigation</div>
                </div>

                <div class="tab-content active" id="transactions-tab">
                    <h3>Transactions D√©tect√©es</h3>
                    <div id="transactionList" class="transaction-list">
                        <div class="loading">En attente d'analyse...</div>
                    </div>
                </div>

                <div class="tab-content" id="addresses-tab">
                    <h3>Adresses Connect√©es</h3>
                    <div id="addressList" class="address-list">
                        <div class="loading">En attente d'analyse...</div>
                    </div>
                </div>

                <div class="tab-content" id="details-tab">
                    <h3>D√©tails de l'Adresse</h3>
                    <div id="nodeDetails" class="node-details">
                        <div class="loading">Cliquez sur un n≈ìud pour voir les d√©tails</div>
                    </div>
                </div>

                <div class="tab-content" id="investigation-tab">
                    <h3>Pistes d'Investigation</h3>
                    <div id="investigationPaths" class="investigation-paths">
                        <div class="loading">Analyse des pistes en attente...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // üöÄ VERSION PRO - INVESTIGATION PROFONDE
        let network = null;
        let currentData = { nodes: [], edges: [] };
        let investigatedAddresses = new Set();
        let currentSelectedNode = null;

        // Base de donn√©es √©tendue des exchanges et services
        const knownEntities = {
            // Exchanges KYC
            '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa': { name: 'Genesis', type: 'exchange', risk: 'low' },
            '3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy': { name: 'Binance', type: 'exchange', risk: 'high' },
            '1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2': { name: 'Coinbase', type: 'exchange', risk: 'high' },
            'bc1q34aq5drpkwy6d3g9q8t4z5q6x5k6q5jq4x5k6q': { name: 'Kraken', type: 'exchange', risk: 'high' },
            
            // Mixers et services priv√©s
            '3Cbq7aT1tY8kMxWLbitaG7yT6bPbKChq64': { name: 'Wasabi Wallet', type: 'mixer', risk: 'medium' },
            'bc1qs0z9g2qzyj2n2nffpndd0p5a2y8u8d2i3h4m5n': { name: 'Samourai', type: 'mixer', risk: 'high' },
            
            // Services connus
            '1CounterpartyXXXXXXXXXXXXXXXUWLpVr': { name: 'Counterparty', type: 'service', risk: 'low' }
        };

        async function startDeepAnalysis() {
            const address = document.getElementById('btcAddress').value.trim();
            if (!address) {
                alert('Veuillez entrer une adresse Bitcoin');
                return;
            }

            investigatedAddresses.clear();
            await investigateAddress(address, 0, 3); // 3 niveaux de profondeur
        }

        async function investigateAddress(address, depth, maxDepth) {
            if (depth > maxDepth || investigatedAddresses.has(address)) {
                return;
            }

            investigatedAddresses.add(address);

            try {
                const response = await fetch(`https://blockchain.info/rawaddr/${address}?limit=100`);
                if (!response.ok) return;

                const data = await response.json();
                await processAddressData(data, address, depth);

                // Investiguer les adresses connect√©es (niveau suivant)
                if (depth < maxDepth) {
                    const connectedAddresses = getConnectedAddresses(data, address);
                    for (const connectedAddr of connectedAddresses.slice(0, 10)) { // Limiter pour performance
                        await investigateAddress(connectedAddr, depth + 1, maxDepth);
                    }
                }

            } catch (error) {
                console.error('Erreur investigation:', error);
            }
        }

        function getConnectedAddresses(blockchainData, originalAddress) {
            const addresses = new Set();

            blockchainData.txs.forEach(tx => {
                // Adresses sortantes
                tx.inputs.forEach(input => {
                    if (input.prev_out && input.prev_out.addr === originalAddress) {
                        tx.out.forEach(output => {
                            if (output.addr && output.addr !== originalAddress) {
                                addresses.add(output.addr);
                            }
                        });
                    }
                });

                // Adresses entrantes
                tx.out.forEach(output => {
                    if (output.addr === originalAddress) {
                        tx.inputs.forEach(input => {
                            if (input.prev_out && input.prev_out.addr && input.prev_out.addr !== originalAddress) {
                                addresses.add(input.prev_out.addr);
                            }
                        });
                    }
                });
            });

            return Array.from(addresses);
        }

        async function processAddressData(blockchainData, address, depth) {
            // Cr√©er le n≈ìud principal
            const nodeInfo = knownEntities[address] || { 
                name: 'Wallet', 
                type: 'unknown', 
                risk: 'medium' 
            };

            const node = {
                id: address,
                label: `${nodeInfo.name}\n${address.substring(0, 6)}...`,
                color: getNodeColor(nodeInfo.type, depth),
                group: nodeInfo.type,
                address: address,
                depth: depth,
                balance: (blockchainData.final_balance / 100000000).toFixed(8),
                total_received: (blockchainData.total_received / 100000000).toFixed(8),
                total_sent: (blockchainData.total_sent / 100000000).toFixed(8),
                txCount: blockchainData.n_tx,
                first_seen: blockchainData.txs.length > 0 ? new Date(blockchainData.txs[blockchainData.txs.length-1].time * 1000).toLocaleDateString() : 'N/A'
            };

            if (!currentData.nodes.find(n => n.id === address)) {
                currentData.nodes.push(node);
            }

            // Traiter les transactions
            await processTransactions(blockchainData.txs, address, depth);
            updateVisualization();
            updateUI(blockchainData);
        }

        function getNodeColor(type, depth) {
            const colors = {
                'exchange': '#ff4757',
                'mixer': '#ffa502',
                'service': '#2ed573',
                'unknown': '#a4b0be'
            };
            
            const baseColor = colors[type] || '#a4b0be';
            // Assombrir selon la profondeur
            return baseColor;
        }

        async function processTransactions(transactions, address, depth) {
            for (const tx of transactions.slice(0, 50)) {
                await processSingleTransaction(tx, address, depth);
            }
        }

        async function processSingleTransaction(tx, address, depth) {
            // Transaction sortante
            tx.inputs.forEach(input => {
                if (input.prev_out && input.prev_out.addr === address) {
                    tx.out.forEach(output => {
                        if (output.addr && output.addr !== address) {
                            addTransactionEdge(
                                address, 
                                output.addr, 
                                output.value, 
                                tx.hash, 
                                tx.time, 
                                'outgoing'
                            );
                        }
                    });
                }
            });

            // Transaction entrante
            tx.out.forEach(output => {
                if (output.addr === address) {
                    tx.inputs.forEach(input => {
                        if (input.prev_out && input.prev_out.addr && input.prev_out.addr !== address) {
                            addTransactionEdge(
                                input.prev_out.addr, 
                                address, 
                                input.prev_out.value, 
                                tx.hash, 
                                tx.time, 
                                'incoming'
                            );
                        }
                    });
                }
            });
        }

        function addTransactionEdge(from, to, value, hash, timestamp, direction) {
            const edgeId = `${from}-${to}-${hash}`;
            
            if (!currentData.edges.find(e => e.id === edgeId)) {
                currentData.edges.push({
                    id: edgeId,
                    from: from,
                    to: to,
                    label: (value / 100000000).toFixed(4) + ' BTC',
                    value: value / 100000000,
                    color: direction === 'outgoing' ? '#ff4757' : '#2ed573',
                    txHash: hash,
                    timestamp: new Date(timestamp * 1000).toLocaleString(),
                    arrows: 'to'
                });
            }
        }

        function updateVisualization() {
            const container = document.getElementById('network');
            
            if (!network) {
                const options = {
                    nodes: {
                        shape: 'dot',
                        size: 25,
                        font: { size: 11, color: '#ffffff' },
                        borderWidth: 2
                    },
                    edges: {
                        width: 2,
                        arrows: { to: { enabled: true } },
                        font: { color: '#ffffff', size: 9 }
                    },
                    physics: { enabled: true }
                };
                
                network = new vis.Network(container, currentData, options);
                
                network.on("click", function (params) {
                    if (params.nodes.length > 0) {
                        currentSelectedNode = params.nodes[0];
                        showNodeDetails(currentSelectedNode);
                    }
                });
            } else {
                network.setData(currentData);
            }
        }

        function showNodeDetails(nodeId) {
            const node = currentData.nodes.find(n => n.id === nodeId);
            if (!node) return;

            const detailsHtml = `
                <div class="detail-section">
                    <strong>üîç Adresse Compl√®te:</strong><br>
                    <div style="background: rgba(0,0,0,0.3); padding: 8px; border-radius: 5px; margin: 8px 0; word-break: break-all;">
                        ${node.address}
                    </div>
                </div>

                <div class="detail-section">
                    <strong>üí∞ Balance Actuelle:</strong> ${node.balance} BTC<br>
                    <strong>üì• Total Re√ßu:</strong> ${node.total_received} BTC<br>
                    <strong>üì§ Total Envoy√©:</strong> ${node.total_sent} BTC<br>
                    <strong>üîÑ Transactions:</strong> ${node.txCount}<br>
                    <strong>üìÖ Premi√®re Vue:</strong> ${node.first_seen}<br>
                    <strong>üéØ Niveau Investigation:</strong> ${node.depth}
                </div>

                <div class="detail-section">
                    <strong>üè∑Ô∏è Tags & Risque:</strong><br>
                    <span class="risk-badge risk-${node.group === 'exchange' ? 'high' : 'medium'}">
                        ${knownEntities[node.address] ? knownEntities[node.address].name.toUpperCase() : 'UNKNOWN'}
                    </span>
                    <span class="risk-badge risk-${node.txCount > 1000 ? 'high' : node.txCount > 100 ? 'medium' : 'low'}">
                        ${node.txCount} TXS
                    </span>
                </div>

                <div class="action-buttons">
                    <button class="action-btn" onclick="copyToClipboard('${node.address}')">üìã Copier Adresse</button>
                    <button class="action-btn" onclick="openInExplorer('${node.address}')">üîç Explorer Blockchain</button>
                    <button class="action-btn" onclick="investigateDeeper('${node.address}')">üîÑ Investiguer Plus</button>
                    <button class="action-btn" onclick="findConnections('${node.address}')">üîó Voir Connexions</button>
                    ${knownEntities[node.address] ? 
                        `<button class="action-btn" style="background: #ff4757;" onclick="reportKYCFound('${node.address}')">üö® Signaler KYC</button>` : 
                        ''
                    }
                </div>
            `;

            document.getElementById('nodeDetails').innerHTML = detailsHtml;
            switchTab('details');
        }

        function updateUI(blockchainData) {
            updateTransactionList(blockchainData);
            updateAddressList();
            updateInvestigationPaths();
        }

        function updateTransactionList(blockchainData) {
            const container = document.getElementById('transactionList');
            let html = '';

            blockchainData.txs.slice(0, 20).forEach(tx => {
                const isIncoming = tx.out.some(output => 
                    output.addr === blockchainData.address
                );

                const amount = isIncoming ? 
                    tx.out.find(output => output.addr === blockchainData.address).value :
                    tx.inputs.reduce((sum, input) => sum + (input.prev_out?.value || 0), 0);

                html += `
                    <div class="transaction-item" onclick="showTransactionDetails('${tx.hash}')">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${(amount / 100000000).toFixed(8)} BTC</strong>
                            <span class="risk-badge risk-${isIncoming ? 'low' : 'medium'}">
                                ${isIncoming ? 'ENTRANT' : 'SORTANT'}
                            </span>
                        </div>
                        <div style="font-size: 11px; margin-top: 8px;">
                            <div>Hash: ${tx.hash.substring(0, 25)}...</div>
                            <div style="color: #ccc;">${new Date(tx.time * 1000).toLocaleString()}</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html || '<div class="loading">Aucune transaction trouv√©e</div>';
        }

        function updateAddressList() {
            const container = document.getElementById('addressList');
            let html = '';

            currentData.nodes.forEach(node => {
                const entity = knownEntities[node.address];
                html += `
                    <div class="address-item" onclick="showNodeDetails('${node.address}')">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${entity ? entity.name : 'Wallet Inconnu'}</strong>
                            <span class="risk-badge risk-${entity ? entity.risk : 'medium'}">
                                ${entity ? entity.type.toUpperCase() : 'UNKNOWN'}
                            </span>
                        </div>
                        <div style="font-size: 11px; margin-top: 8px;">
                            <div>${node.address.substring(0, 20)}...</div>
                            <div style="color: #ccc;">${node.txCount} transactions ‚Ä¢ Niveau ${node.depth}</div>
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html || '<div class="loading">Aucune adresse trouv√©e</div>';
        }

        function updateInvestigationPaths() {
            const container = document.getElementById('investigationPaths');
            
            // Trouver les chemins vers les exchanges KYC
            const kycPaths = findPathsToKYC();
            
            let html = '<h4>üéØ Chemins vers les Exchanges KYC</h4>';
            
            if (kycPaths.length > 0) {
                kycPaths.forEach((path, index) => {
                    html += `<div class="investigation-path">
                        <strong>Chemin ${index + 1}:</strong>
                        <div class="path-steps">`;
                    
                    path.forEach((address, stepIndex) => {
                        const entity = knownEntities[address];
                        html += `<div class="path-step">
                            <span>${stepIndex + 1}. ${entity ? entity.name : 'Wallet'}</span>
                            <span style="font-family: monospace; font-size: 10px; margin-left: 10px;">
                                ${address.substring(0, 15)}...
                            </span>
                            ${stepIndex < path.length - 1 ? '<span class="path-arrow">‚Üí</span>' : ''}
                        </div>`;
                    });
                    
                    html += `</div></div>`;
                });
            } else {
                html += '<div class="loading">Aucun chemin KYC identifi√© pour le moment</div>';
            }

            container.innerHTML = html;
        }

        function findPathsToKYC() {
            const paths = [];
            const sourceAddress = document.getElementById('btcAddress').value.trim();
            
            currentData.edges.forEach(edge => {
                if (edge.from === sourceAddress) {
                    const toEntity = knownEntities[edge.to];
                    if (toEntity && toEntity.type === 'exchange') {
                        paths.push([sourceAddress, edge.to]);
                    }
                    
                    // Chercher un niveau plus profond
                    currentData.edges.forEach(deepEdge => {
                        if (deepEdge.from === edge.to) {
                            const deepEntity = knownEntities[deepEdge.to];
                            if (deepEntity && deepEntity.type === 'exchange') {
                                paths.push([sourceAddress, edge.to, deepEdge.to]);
                            }
                        }
                    });
                }
            });
            
            return paths.slice(0, 5); // Limiter √† 5 chemins
        }

        // Fonctions de contr√¥le
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            document.querySelector(`.tab[onclick="switchTab('${tabName}')"]`).classList.add('active');
            document.getElementById(`${tabName}-tab`).classList.add('active');
        }

        function expandNetwork() {
            const currentAddress = document.getElementById('btcAddress').value.trim();
            if (currentAddress) {
                investigateAddress(currentAddress, 0, 4); // Un niveau de plus
            }
        }

        function findKYCPaths() {
            updateInvestigationPaths();
            switchTab('investigation');
        }

        function investigateDeeper(address) {
            investigateAddress(address, 0, 2);
        }

        function findConnections(address) {
            // Focus sur les connexions de cette adresse
            const connectedEdges = currentData.edges.filter(edge => 
                edge.from === address || edge.to === address
            );
            
            const connectedNodes = new Set();
            connectedEdges.forEach(edge => {
                connectedNodes.add(edge.from);
                connectedNodes.add(edge.to);
            });
            
            // Mettre en √©vidence ces n≈ìuds
            // (Impl√©mentation visuelle √† compl√©ter)
        }

        function exportData() {
            const dataStr = JSON.stringify(currentData, null, 2);
            const dataBlob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(dataBlob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'bitcoin-investigation.json';
            link.click();
        }

        function clearNetwork() {
            currentData = { nodes: [], edges: [] };
            investigatedAddresses.clear();
            updateVisualization();
            document.getElementById('transactionList').innerHTML = '<div class="loading">En attente d\'analyse...</div>';
            document.getElementById('addressList').innerHTML = '<div class="loading">En attente d\'analyse...</div>';
            document.getElementById('nodeDetails').innerHTML = '<div class="loading">Cliquez sur un n≈ìud pour voir les d√©tails</div>';
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text);
            alert('Adresse copi√©e: ' + text);
        }

        function openInExplorer(address) {
            window.open(`https://blockchain.com/explorer/addresses/btc/${address}`, '_blank');
        }

        function reportKYCFound(address) {
            const entity = knownEntities[address];
            alert(`üö® EXCHANGE KYC IDENTIFI√â!\n\nExchange: ${entity.name}\nAdresse: ${address}\n\nSignalez cette information dans votre plainte!`);
        }

        function showTransactionDetails(hash) {
            window.open(`https://blockchain.com/explorer/transactions/btc/${hash}`, '_blank');
        }

        // Initialisation
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('btcAddress').value = '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa';
        });
    </script>
</body>
</html>