<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>headmap forest</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;

        }

        #tooltip {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 10px 15px;
            border-radius: 5px;
            display: none;
            pointer-events: none;
            font-family: Arial, sans-serif;
            font-size: 14px;
            max-width: 250px;
            z-index: 100;
            border: 1px solid #444;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial, sans-serif;
            font-size: 18px;
            background: rgba(0, 0, 0, 0.7);
            padding: 20px;
            border-radius: 5px;
        }
    </style>
</head>

<body>
    <div id="tooltip"></div>
    <div id="loading">Headmap forest Chargement en cours...</div>
    <script type="module">
        import * as THREE from "https://esm.sh/three";
        import { OrbitControls } from "https://esm.sh/three/examples/jsm/controls/OrbitControls";
        import { GLTFLoader } from "https://esm.sh/three/examples/jsm/loaders/GLTFLoader";

        // Initialisation
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth / window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Fond d'écran
        new THREE.TextureLoader().load('https://github.com/berru-g/plane/blob/main/avion/layered.jpg?raw=true',
            texture => scene.background = texture
        );

        // Contrôles
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.25;

        // Sphère (Terre)
        const earthGeometry = new THREE.SphereGeometry(5, 64, 64);
        const earthTexture = new THREE.TextureLoader().load('https://raw.githubusercontent.com/mrdoob/three.js/refs/heads/dev/examples/textures/terrain/grasslight-big.jpg');
        const earthMaterial = new THREE.MeshPhongMaterial({
            map: earthTexture,
            specular: new THREE.Color(0x111111),
            shininess: 5
        });
        const earth = new THREE.Mesh(earthGeometry, earthMaterial);
        scene.add(earth);

        // Lumière directionnelle fixe (par rapport à l'écran)
        const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
        directionalLight.position.set(1, 1, 1).normalize();
        scene.add(directionalLight);

        // Lumière ambiante
        scene.add(new THREE.AmbientLight(0x404040, 0.7));

        // Position caméra
        camera.position.z = 10;

        // Tooltip
        const tooltip = document.getElementById('tooltip');
        const loadingElement = document.getElementById('loading');

        // Chargement du modèle d'arbre
        let treeModel = null;
        const loader = new GLTFLoader();

        loader.load(
            'https://raw.githubusercontent.com/berru-g/crypto-tool/main/headmap-forest/arbre1.glb',
            (gltf) => {
                treeModel = gltf.scene;
                treeModel.traverse(child => {
                    if (child.isMesh) {
                        child.castShadow = true;
                        child.receiveShadow = true;
                    }
                });
                // Une fois le modèle chargé, charger les données
                fetchTokenData();
            },
            (xhr) => {
                console.log((xhr.loaded / xhr.total * 100) + '% loaded');
            },
            (error) => {
                console.error('Erreur chargement modèle:', error);
                loadingElement.textContent = "Erreur de chargement du modèle 3D. Utilisation des cylindres simples.";
                treeModel = null;
                fetchTokenData();
            }
        );

        // Création d'un arbre avec le modèle GLB ou un cylindre simple
        function createTree(size, lat, lon, tokenData) {
            const baseSize = Math.max(0.3, Math.log10(tokenData.total_volume + 1) / 2);
            const treeGroup = new THREE.Group();

            if (treeModel) {
                // Utilisation du modèle GLB
                const treeInstance = treeModel.clone();
                treeInstance.scale.set(baseSize, baseSize, baseSize);
                treeGroup.add(treeInstance);
            } else {
                // Fallback: cylindre simple
                const trunkHeight = baseSize * 0.5;
                const trunkGeometry = new THREE.CylinderGeometry(0.05, 0.08, trunkHeight, 8);
                const trunkMaterial = new THREE.MeshPhongMaterial({ color: 0x8B4513 });
                const trunk = new THREE.Mesh(trunkGeometry, trunkMaterial);
                trunk.position.y = trunkHeight / 2;
                treeGroup.add(trunk);

                const foliageSize = baseSize * 0.4;
                const foliageGeometry = new THREE.SphereGeometry(foliageSize, 16, 16);
                const foliageMaterial = new THREE.MeshPhongMaterial({
                    color: new THREE.Color(`hsl(${100 + Math.random() * 40}, 70%, 50%)`),
                    transparent: true,
                    opacity: 0.9
                });
                const foliage = new THREE.Mesh(foliageGeometry, foliageMaterial);
                foliage.position.y = trunkHeight + foliageSize * 0.3;
                treeGroup.add(foliage);
            }

            // Positionnement sur la sphère
            const phi = (90 - lat) * (Math.PI / 180);
            const theta = (lon + 180) * (Math.PI / 180);
            const radius = 5.05;

            treeGroup.position.x = - (radius * Math.sin(phi) * Math.cos(theta));
            treeGroup.position.y = radius * Math.cos(phi);
            treeGroup.position.z = radius * Math.sin(phi) * Math.sin(theta);

            treeGroup.lookAt(earth.position);
            treeGroup.rotateX(Math.PI / 2);

            // Stockage des données du token
            treeGroup.userData = {
                name: tokenData.name,
                symbol: tokenData.symbol,
                volume: tokenData.total_volume,
                price: tokenData.current_price,
                isTree: true
            };

            return treeGroup;
        }

        // Récupération données CoinGecko
        async function fetchTokenData() {
            try {
                loadingElement.textContent = "Chargement des données crypto...";
                const response = await fetch('https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=50');
                const data = await response.json();

                // Supprimer anciens arbres
                scene.children.filter(child => child.userData?.isTree).forEach(tree => scene.remove(tree));

                // Créer nouveaux arbres
                data.forEach(token => {
                    if (token.total_volume > 0) {
                        const lat = Math.random() * 160 - 80;
                        const lon = Math.random() * 360 - 180;
                        const tree = createTree(1, lat, lon, token);
                        scene.add(tree);
                    }
                });

                console.log(`${data.length} tokens chargés`);
                loadingElement.style.display = 'none';
            } catch (error) {
                console.error('Erreur API:', error);
                loadingElement.textContent = "Erreur API. Utilisation des données de démo.";

                // Données de démo
                const demoData = [
                    { name: "Bitcoin", symbol: "BTC", total_volume: 20000000000, current_price: 50000 },
                    { name: "Ethereum", symbol: "ETH", total_volume: 10000000000, current_price: 3000 },
                    { name: "Cardano", symbol: "ADA", total_volume: 5000000000, current_price: 1.5 },
                    { name: "Solana", symbol: "SOL", total_volume: 3000000000, current_price: 150 },
                    { name: "Polkadot", symbol: "DOT", total_volume: 2000000000, current_price: 30 }
                ];

                demoData.forEach((token, i) => {
                    const tree = createTree(1, 30 + i * 20, -100 + i * 40, token);
                    scene.add(tree);
                });

                setTimeout(() => {
                    loadingElement.style.display = 'none';
                }, 2000);
            }
        }

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let hoveredTree = null;

        function onMouseMove(event) {
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);

            // Cibler spécifiquement les arbres
            const intersects = raycaster.intersectObjects(scene.children, true);

            if (intersects.length > 0) {
                // Trouver le premier objet qui a des userData de token
                let tree = null;
                for (let i = 0; i < intersects.length; i++) {
                    let obj = intersects[i].object;
                    // Remonter jusqu'au groupe parent si nécessaire
                    while (obj && !obj.userData?.isTree && obj.parent) {
                        obj = obj.parent;
                    }
                    if (obj.userData?.isTree) {
                        tree = obj;
                        break;
                    }
                }

                if (tree) {
                    if (hoveredTree !== tree) {
                        hoveredTree = tree;

                        // Afficher le tooltip
                        tooltip.style.display = 'block';
                        tooltip.style.left = `${event.clientX + 15}px`;
                        tooltip.style.top = `${event.clientY + 15}px`;
                        tooltip.innerHTML = `
                        <strong>${tree.userData.name} (${tree.userData.symbol})</strong><br>
                        Volume 24h: $${tree.userData.volume.toLocaleString()}<br>
                        Prix: $${tree.userData.price?.toLocaleString() || 'N/A'}
                    `;

                        // Surbrillance
                        tree.traverse(child => {
                            if (child.isMesh) {
                                if (!child.originalEmissive) {
                                    child.originalEmissive = child.material.emissive?.clone() || new THREE.Color(0x000000);
                                }
                                child.material.emissive = new THREE.Color(0x555555);
                            }
                        });
                    }
                    return;
                }
            }

            // Si on arrive ici, aucun arbre n'est survolé
            if (hoveredTree) {
                hoveredTree.traverse(child => {
                    if (child.isMesh && child.originalEmissive) {
                        child.material.emissive = child.originalEmissive;
                    }
                });
                hoveredTree = null;
                tooltip.style.display = 'none';
            }
        }
        window.addEventListener('mousemove', onMouseMove, false);

        // Animation
        function animate() {
            requestAnimationFrame(animate);

            // Maintenir la lumière fixe par rapport à la caméra
            directionalLight.position.copy(camera.position).normalize();

            controls.update();
            renderer.render(scene, camera);
        }

        // Redimensionnement
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Démarrer l'animation
        animate();
    </script>
</body>

</html>