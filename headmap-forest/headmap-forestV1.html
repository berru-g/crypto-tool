<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Crypto Globe - Version Finale</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden;
            background: #000;
        }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-family: Arial;
            padding: 20px;
            background: rgba(0,0,0,0.7);
            border-radius: 5px;
            z-index: 100;
            max-width: 80%;
            text-align: center;
        }
        #tooltip {
            position: absolute;
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 12px;
            border-radius: 5px;
            font-family: Arial;
            font-size: 14px;
            pointer-events: none;
            z-index: 101;
            max-width: 250px;
            display: none;
            border: 1px solid #444;
        }
        canvas { 
            display: block; 
            width: 100% !important;
            height: 100% !important;
        }
    </style>
</head>
<body>
    <div id="loading">Initialisation du Crypto Globe...</div>
    <div id="tooltip"></div>

    <script type="module">
        // ====== CONFIGURATION ======
        const loadingElement = document.getElementById('loading');
        const tooltipElement = document.getElementById('tooltip');
        
        // URLs des ressources (modifiables facilement)
        const RESOURCES = {
            earthTexture: 'https://raw.githubusercontent.com/mrdoob/three.js/dev/examples/textures/planets/earth_atmos_2048.jpg',
            treeModels: [
                'https://raw.githubusercontent.com/berru-g/crypto-tool/main/headmap-forest/arbre1.glb',
                'https://raw.githubusercontent.com/berru-g/crypto-tool/main/headmap-forest/arbre2.glb'
            ],
            coinGeckoAPI: 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=50'
        };

        // ====== INITIALISATION THREE.JS ======
        let THREE, OrbitControls, GLTFLoader;
        
        try {
            // Chargement asynchrone des dépendances
            THREE = await import("https://esm.sh/three");
            OrbitControls = (await import("https://esm.sh/three/examples/jsm/controls/OrbitControls")).OrbitControls;
            GLTFLoader = (await import("https://esm.sh/three/examples/jsm/loaders/GLTFLoader")).GLTFLoader;
            
            loadingElement.textContent = "Chargement des composants...";
        } catch (e) {
            loadingElement.textContent = "Erreur : librairies non chargées. Voir console (F12)";
            console.error(e);
            throw e;
        }

        // ====== SCÈNE PRINCIPALE ======
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ 
            antialias: true,
            powerPreference: "high-performance"
        });
        
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // ====== GESTION DU REDIMENSIONNEMENT ======
        const handleResize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
        window.addEventListener('resize', handleResize);

        // ====== FONCTIONS PRINCIPALES ======
        async function createEarth() {
            try {
                const texture = await new THREE.TextureLoader().loadAsync(RESOURCES.earthTexture);
                const earth = new THREE.Mesh(
                    new THREE.SphereGeometry(5, 64, 64),
                    new THREE.MeshPhongMaterial({ 
                        map: texture,
                        specular: new THREE.Color(0x111111),
                        shininess: 15
                    })
                );
                scene.add(earth);
                return earth;
            } catch (e) {
                console.warn("Texture Earth non chargée, utilisation d'une sphère simple");
                const earth = new THREE.Mesh(
                    new THREE.SphereGeometry(5, 32, 32),
                    new THREE.MeshPhongMaterial({ color: 0x1E90FF })
                );
                scene.add(earth);
                return earth;
            }
        }

        async function loadTreeModels() {
            const models = [];
            for (const url of RESOURCES.treeModels) {
                try {
                    const model = await new GLTFLoader().loadAsync(url);
                    model.scene.traverse(child => {
                        if (child.isMesh) {
                            child.castShadow = true;
                        }
                    });
                    model.scene.visible = false;
                    scene.add(model.scene);
                    models.push(model.scene);
                } catch (e) {
                    console.warn(`Modèle ${url} non chargé : ${e.message}`);
                }
            }
            return models;
        }

        async function fetchCryptoData() {
            try {
                const response = await fetch(RESOURCES.coinGeckoAPI);
                const data = await response.json();
                return data.filter(token => token.total_volume > 0);
            } catch (e) {
                console.warn("API CoinGecko hors ligne, utilisation des données de test");
                return [
                    { name: "Bitcoin", symbol: "BTC", total_volume: 25000000000, current_price: 50000 },
                    { name: "Ethereum", symbol: "ETH", total_volume: 15000000000, current_price: 3000 },
                    { name: "Cardano", symbol: "ADA", total_volume: 5000000000, current_price: 1.5 }
                ];
            }
        }

        function createTree(model, size, lat, lon, tokenData, earth) {
            const tree = model.clone();
            tree.visible = true;
            tree.scale.set(size, size, size);
            
            // Positionnement sphérique
            const phi = (90 - lat) * Math.PI/180;
            const theta = lon * Math.PI/180;
            const radius = 5.05;
            
            tree.position.x = -radius * Math.sin(phi) * Math.cos(theta);
            tree.position.y = radius * Math.cos(phi);
            tree.position.z = radius * Math.sin(phi) * Math.sin(theta);
            
            tree.lookAt(earth.position);
            tree.rotateX(Math.PI/2);
            
            // Stockage des données
            tree.userData = {
                name: tokenData.name,
                symbol: tokenData.symbol,
                volume: tokenData.total_volume,
                price: tokenData.current_price,
                isTree: true
            };
            
            return tree;
        }

        // ====== INITIALISATION COMPLÈTE ======
        async function init() {
            try {
                // 1. Créer la Terre
                loadingElement.textContent = "Création de la Terre...";
                const earth = await createEarth();
                
                // 2. Charger les modèles d'arbres
                loadingElement.textContent = "Chargement des modèles 3D...";
                const treeModels = await loadTreeModels();
                if (treeModels.length === 0) {
                    console.warn("Aucun modèle 3D chargé, création d'un arbre basique");
                    const basicTree = new THREE.Group();
                    const trunk = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.1, 0.15, 1, 8),
                        new THREE.MeshPhongMaterial({ color: 0x8B4513 })
                    );
                    trunk.position.y = 0.5;
                    basicTree.add(trunk);
                    
                    const foliage = new THREE.Mesh(
                        new THREE.SphereGeometry(0.5, 16, 16),
                        new THREE.MeshPhongMaterial({ color: 0x00AA00 })
                    );
                    foliage.position.y = 1.2;
                    basicTree.add(foliage);
                    
                    treeModels.push(basicTree);
                }
                
                // 3. Récupérer les données crypto
                loadingElement.textContent = "Connexion à l'API...";
                const cryptoData = await fetchCryptoData();
                
                // 4. Créer les arbres
                loadingElement.textContent = "Génération des arbres...";
                const trees = [];
                const volumes = cryptoData.map(t => t.total_volume);
                const minVol = Math.min(...volumes);
                const maxVol = Math.max(...volumes);
                
                cryptoData.forEach((token, i) => {
                    const size = 0.3 + 0.7 * (Math.log(token.total_volume) - Math.log(minVol)) / (Math.log(maxVol) - Math.log(minVol));
                    const lat = Math.random() * 160 - 80;
                    const lon = Math.random() * 360;
                    const model = treeModels[i % treeModels.length];
                    
                    const tree = createTree(model, size, lat, lon, token, earth);
                    scene.add(tree);
                    trees.push(tree);
                });
                
                // 5. Configurer les lumières
                const light = new THREE.DirectionalLight(0xffffff, 1.5);
                light.position.set(5, 3, 5);
                scene.add(light);
                scene.add(new THREE.AmbientLight(0x404040, 0.7));
                
                // 6. Contrôles de la caméra
                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                camera.position.z = 15;
                
                // 7. Gestion des tooltips
                const raycaster = new THREE.Raycaster();
                const mouse = new THREE.Vector2();
                
                window.addEventListener('mousemove', (event) => {
                    mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(trees, true);
                    
                    if (intersects.length > 0) {
                        let obj = intersects[0].object;
                        while (obj && !obj.userData?.isTree && obj.parent) {
                            obj = obj.parent;
                        }
                        
                        if (obj?.userData?.isTree) {
                            const token = obj.userData;
                            tooltipElement.style.display = 'block';
                            tooltipElement.style.left = `${event.clientX + 15}px`;
                            tooltipElement.style.top = `${event.clientY + 15}px`;
                            tooltipElement.innerHTML = `
                                <strong>${token.name} (${token.symbol})</strong><br>
                                Volume 24h: $${(token.volume/1000000000).toFixed(1)}B<br>
                                Prix: $${token.price.toLocaleString()}
                            `;
                            return;
                        }
                    }
                    
                    tooltipElement.style.display = 'none';
                });
                
                // 8. Animation
                const animate = () => {
                    requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                };
                animate();
                
                // Tout est prêt !
                loadingElement.style.display = 'none';
                console.log("=== CRYPTO GLOBE PRÊT ===");
                console.log(`${trees.length} arbres créés`);
                console.log(`Données : ${cryptoData.length} tokens`);
                
            } catch (e) {
                console.error("ERREUR CRITIQUE :", e);
                loadingElement.textContent = `Erreur : ${e.message || "Voir console (F12)"}`;
            }
        }

        // Démarrer l'application
        init();
    </script>
</body>
</html>